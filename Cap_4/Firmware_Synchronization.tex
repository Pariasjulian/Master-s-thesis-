\chapter{Firmware Architecture and Temporal Synchronization Strategy}
\label{ch:firmware_sync}

This section delves into the embedded computational logic governing the MONEEE hardware and its interface with the simulation environment. It describes the central methodological contribution of this development: a hardware-level event injection mechanism designed to mitigate the stochastic latency inherent to general-purpose operating systems, thereby achieving precise synchronization between physiological data and game stimuli at the microcontroller (MCU) level.

\section{Deterministic Firmware Design on the TM4C1294}
\label{sec:tm4c_firmware}

The firmware resident on the Texas Instruments TM4C1294 microcontroller has been structured under a \textit{bare-metal} paradigm (dispensing with a complex operating system) to guarantee strictly deterministic behavior. The software architecture is event-driven, establishing an execution hierarchy where data acquisition holds maximum priority, subordinating any communication or maintenance tasks.

The synchronization engine depends on the precise management of the \texttt{DRDY} (Data Ready) interrupt signal generated by the ADS1299 converter. This signal activates the capture logic at the programmed sampling frequency (e.g., 250 Hz, corresponding to a 4 ms period).

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{Cap_4/Figure/isr_flowchart.png}
    \caption{Flowchart of the Interrupt Service Routine (ISR) associated with the Data Ready signal (DRDY).}
    \label{fig:isr_flowchart}
\end{figure}

The sequence of operations within the Interrupt Service Routine (ISR) is critical for maintaining the system's phase coherence. Upon detection of the falling edge of the \texttt{DRDY} signal, the microcontroller activates the \textit{Chip Select} (\texttt{CS}) line of the SPI bus and initiates a Direct Memory Access (DMA) transfer. This mechanism allows for the automatic reading of 24 bytes of data (8 channels of 24 bits plus status bits) without CPU intervention, which is reserved for managing storage in a circular buffer and verifying event flags.

\subsection{Hardware Event Injection Strategy}
To resolve the problem of temporal desynchronization, the system design dispenses with PC or Raspberry Pi clocks for event \textit{timestamping}. Instead, a direct injection strategy into the data frame is implemented.

The operation of this mechanism is based on the immediate reception of commands. When the stimulation software (Game) generates a visual event, it transmits an 8-bit hexadecimal code (e.g., \texttt{0x0A}) via the USB-C interface to the TM4C. The arrival of this byte triggers a high-priority interrupt in the MCU, which immediately stores the value in a volatile register named \texttt{Current\_Event}. During the subsequent ADS1299 sampling cycle (which occurs within an interval of less than 4 ms), the ISR queries this register and concatenates the event code directly to the end of the EEG data packet in progress. In this way, the event marker and the physiological sample become physically linked within the same data structure before being transmitted to the Linux environment. This approach ensures that the relative \textit{jitter} between the stimulus and the biological response is virtually null, bounded only by the temporal resolution of the sampling period.

\section{Integration Protocol with the Simulation Environment}
\label{sec:game_integration}

Interaction with the serious game, developed in the Unity engine, is managed via a custom communication library that acts as an abstraction layer over the tablet's serial API. This library exposes high-level methods, such as \texttt{SendMarker(int code)}, which are invoked by the game logic at the exact instant of stimulus rendering.

To guarantee the integrity of commands transmitted over the USB link and prevent the erroneous interpretation of electromagnetic noise as valid events, a robust binary protocol has been defined. The transmission structure consists of 3-byte frames, detailed in Table \ref{tab:protocol}.

\begin{table}[ht]
    \centering
    \caption{Definition of the Serial Event Transmission Protocol.}
    \label{tab:protocol}
    \begin{tabular}{ccc}
        \toprule
        \textbf{Byte 0 (Header)} & \textbf{Byte 1 (Payload)} & \textbf{Byte 2 (Footer)} \\
        \midrule
        Start Marker & Event Code & Validation \\
        \texttt{0xFF} & \texttt{0x00 - 0xFE} & \texttt{0xAA} \\
        \bottomrule
    \end{tabular}
\end{table}

The protocol uses the byte \texttt{0xFF} to signal the start of a transaction, followed by the event identifier (where specific codes denote states such as login, standard stimulus, or \textit{oddball} stimulus). The frame concludes with the byte \texttt{0xAA}, used for integrity validation; any sequence that does not respect this structure is immediately discarded by the TM4C firmware, ensuring high noise immunity.

\section{Processing in the Compute Module (Raspberry Pi CM4)}
\label{sec:rpi_software}

The Raspberry Pi Compute Module 4 plays the role of an aggregation node and data gateway. While strict synchronization is the responsibility of the microcontroller, the CM4 must process the information flow with sufficient efficiency to prevent communication buffer overflows.

To minimize operating system-induced latency, the Linux kernel on the CM4 has been optimized using the \textit{PREEMPT\_RT} patch. This modification transforms Linux into a real-time operating system, allowing execution threads associated with hardware drivers (such as the UART receiver) to preempt standard user-space processes. Additionally, core isolation techniques are employed (\textit{CPU shielding} via the \texttt{isolcpus} parameter), dedicating specific processor cores exclusively to data ingestion and freeing them from non-critical interruptions such as Wi-Fi network management or the graphical interface.

Finally, the application software on the CM4, developed in a hybrid Python/C++ environment, ingests the binary packets coming from the TM4C, extracts the injected event markers, and reformats the continuous stream to the Extensible Data Format (XDF) standard. This format, native to the \textit{Lab Streaming Layer} (LSL) middleware, allows multimodal time series to be encapsulated, facilitating the coexistence of EEG samples and discrete event markers in parallel streams with a unified time base, thus optimizing analytical post-processing.